from enum import Enum
import pickle
import subprocess


terminal_test = "terminal_test.txt"
# This function has the purpose of keeping track of the commands that will be executed from the command line
# by saving them in the text file content specified by the terminal_test variable
def write_to_terminal(content):
    try:
        with open(terminal_test, 'a') as file:
            file.write(content+'\n')
        print(f"The content was written correctly to the file: '{terminal_test}'.")
    except IOError:
        print(f"An error occurred while writing to the file: '{terminal_test}'.")

# This function executes the command received as an argument in the shell
def execute(command_to_execute):
    return
    try:
        output = subprocess.run(command_to_execute, shell=True, check=True, capture_output=True, text=True)
        print(output.stdout)  # printout of the stdout generated by the execution of the command
    except subprocess.CalledProcessError as e:
        print("Error executing command:", e)

class Topology:
    def __init__(self):
        self.host_router_links = []
        self.router_router_links = []
    
    # Method for parsing the information describing the topological structure of the network contained in the file_name
    def parse_file(self, file_name):
        with open(file_name, 'r') as file:
            current_section = None
            for line in file:
                line = line.strip()
                if line == "HostToRouter":
                    current_section = "HostToRouter"
                elif line == "RouterToRouter":
                    current_section = "RouterToRouter"
                else:
                    if current_section == "HostToRouter":
                        self.parse_host_router(line)
                    elif current_section == "RouterToRouter":
                        self.parse_router_router(line)

    def parse_host_router(self, line):
        parts = line.strip('()').split(',')
        self.host_router_links.append((parts[0], parts[1]))

    def parse_router_router(self, line):
        links = line.strip('()').split(',') # For example: line = "(s1-eth1-60,s2-eth2-60)" -> links = [ "s1-eth1-60" , "s2-eth2-60" ]
        link_set = []
        for link in links: # First iteration: link = "s1-eth1" ; Second iteration: link = "s2-eth1"
            routers = link.split('-') # routers = [ "s1" , "eth1" ]
            link_set.append(tuple(routers)) # link_set = [ [ "s1" , "eth1" ] , [ "s2" , "eth1" ] ]
        self.router_router_links.append(link_set) # router_router_links = [ [ [ "s1" , "eth1" ] , [ "s2" , "eth1" ] ] , ... ]
        

    def get_host_router_links(self): 
        return self.host_router_links # [ ['h1','r1'] , ['h2','r2'] , ... ]
    
    def get_hosts(self):  
        hosts = []
        for link in self.host_router_links:
            hosts.append(link[0]) # link[0] is first element of the array ['h1','r1']
        return hosts

    def get_router_router_links(self): 
        return self.router_router_links # [ [ ['s1','eth1'] , ['s2','eth1'] ] , ... ]

    def print(self):
        print(f"HostToRouter")
        for link in self.host_router_links:
            print(f"({link[0]},{link[1]})")
        print(f"RouterToRouter")
        for link in self.router_router_links:
            if len(link[0]) == 2:
                print(f"({link[0][0]}-{link[0][1]},{link[1][0]}-{link[1][1]})")
            else:
                print(f"({link[0][0]}-{link[0][1]}-{link[0][2]},{link[1][0]}-{link[1][1]}-{link[0][2]})")
    
class Slice:
    def __init__(self):
        self.slice_topology = Topology()    # slice_topology is a instance of class Topology
        self.slice_name = ""                # slice_name is the file name where the topology of the slice is described
        self.slice_id = 0                   # slice_id is used as base is when queue are created
        self.slice_state = False            # slice_state describe if the slice is activated or not

    def __init__(self, file_name, slice_id):
        self.slice_topology = Topology()
        self.slice_topology.parse_file(file_name)
        self.slice_name = file_name
        self.slice_id = slice_id
        self.slice_state = False

    # Method for getting the hosts which belongs to the slice
    def get_hosts(self):
        return self.slice_topology.get_hosts()

    # Method for the creation of the queue which belongs to the slice
    def activate_queue(self,MAX_RATE):  
        self.slice_state = True
        id = str(self.slice_id)  
        # For each router in the slice and for each port of the router create a queue
        # on that port of the router with the specified bandwidth
        for link in self.slice_topology.get_router_router_links(): # [ [ ['r1','eth1','70'] , ['r2','eth1','70'] ] , ... ]
            for router_port in link: # ['r1','eth1','70']
                first_digit = router_port[1].split('eth')[1] # if router_port is ['r1','eth1','70'], then first_digit is '1' the number of the port
                MAX_SLICE_RATE = int ( (MAX_RATE * int(router_port[2])) / 100 ) 
                command = (f"sudo ovs-vsctl set port {router_port[0]}-{router_port[1]} qos=@newqos"
                            f" -- --id=@newqos create QoS type=linux-htb other-config:max-rate={MAX_RATE} "
                            f"queues:{str(self.slice_id)+router_port[1].split('eth')[1]}=@{first_digit}q -- --id=@{first_digit}q create queue other-config:min-rate=1000000 other-config:max-rate={MAX_SLICE_RATE}")
                
                write_to_terminal(command)
                execute(command)
                print(f"activate_queue {router_port[0]}-{router_port[1]} with slice_id = {self.slice_id}")
    
    # Method for the deactivation of the queue
    def deactivate_queue(self):
        self.slice_state = False
        for link in self.slice_topology.get_router_router_links(): # [ [ ['r1','eth1'] , ['r2','eth1'] ] , ... ]
            for router_port in link: # ['r1','eth1']
                print(f"deactivate_queue {router_port[0]}-{router_port[1]} with slice_id = {self.slice_id}")

    def get_slice_topology(self):
        return self.slice_topology
    
    def get_host_router_links(self): # [ ['h1','r1'] , ['h2','r2'] , ... ]
        return self.slice_topology.get_host_router_links()
    
    def get_router_router_links(self): # [ [ ['h1','eth1'] , ['h2','eth1'] ] , ... ]
        return self.slice_topology.get_router_router_links()

    def print(self):
        print(f"slice_name:{self.slice_name}\tslice_id:{self.slice_id}\tslice_state:{self.slice_state}")
        print(f"slice_topology:")
        self.slice_topology.print()
        
class Network:
    MAX_RATE = 10000000

    def __init__(self):
        self.network_topology_file_name = ""
        self.network_topology = Topology()
        self.slices = []
    
    # Methods for adding a topology
    def add_topology(self, file_name):
        self.__init__()
        self.network_topology_file_name = file_name
        self.network_topology.parse_file(file_name)
        for host_router in self.network_topology.get_host_router_links():
            command = (f"sudo ovs-ofctl add-flow {host_router[1]} ip,priority=65500,nw_src=10.0.0.{host_router[0][1]},nw_dst=0.0.0.0/0,idle_timeout=0,actions=drop")
            write_to_terminal(command)
            execute(command)
    
    # Methods for adding a slice
    def add_slice(self, file_name, option, slice_id):
        slice = Slice(file_name, slice_id)
        self.slices.append(slice)
    
    # Methods for activating the slice named "file_name"
    def activate_slice(self, file_name):
        slice = self.find_slice_by_name(file_name)
        network_topology_hosts = self.get_network_topology_hosts()
        slice_topology = slice.get_slice_topology()
        slice_hosts = self.get_slice_topology_hosts(file_name)
        def find_router_linked_to_the_host(host): # Method taht given a host return the switch connected with the host
            for host_router in slice.get_host_router_links():
                if host_router[0] == host:
                    return host_router[1]
            return
        
        # Restore the network to its previous state, the hosts belonging to the slice must be able to communicate with each other
        # The rules that had been added and which had the purpose of dropping packets from hosts belonging to inactive slices are removed
        for host_router in slice_topology.get_host_router_links():  # host_router = ['h1','s1']
            command = (f"sudo ovs-ofctl del-flows {host_router[1]} ip,nw_src=10.0.0.{host_router[0][1]}")
            write_to_terminal(command)
            execute(command)

        # Creation of queues associated with the slice
        slice.activate_queue(self.MAX_RATE)

        # In this for the logic that allows you to associate the correct queue to be assigned 
        # to each possible nw_src nw_dst pair within a slice is implemented. 
        # To do this operation it is necessary to know the path that the packet 
        # from nw_src to nw_dst will take, i.e. which connections between switches it will cross
        for host_router in slice.get_host_router_links():  # host_router = ['h1','s1']
            for host in slice_hosts:
                if host != host_router[0]: 
                    start_switch = host_router[1]
                    arrival_switch = find_router_linked_to_the_host(host)
                    switch_to_switch_path = self.get_switch_to_switch_path(slice.get_router_router_links(),start_switch,arrival_switch)
                    # switch_to_switch_path = [('s4', 'eth7'), ('s1', 'eth66'), ('s3', 'eth3')]
                    for element in switch_to_switch_path: # ('s4', 'eth7')
                        # queue_id is part of two pieces: -one the slice_id -two the number of the port "123"+"7"
                        queue_id = str(slice.slice_id) + element[1].split('eth')[1] 
                        command = (f"sudo ovs-ofctl add-flow {element[0]} ip,priority=65500," # e.g. s4
                        f"nw_src=10.0.0.{host_router[0][1]},nw_dst=10.0.0.{host[1]},idle_timeout=0,actions=set_queue:{queue_id},normal")
                        write_to_terminal(command)
                        execute(command)
                        print(f"i pachetti che vanno da {host_router[0]} a {host} e passano per {host_router[1]} "
                            f"li assegno alla coda identificata da {slice.slice_id} e che è in {host_router[1]}")
            # I create a "filter": for each host of the slice, I insert the flows that prevent the latter
            # to send packets to hosts that do not belong to the slice
            for host in network_topology_hosts: 
                if host not in slice_hosts:
                    command = (f"sudo ovs-ofctl add-flow {host_router[1]} ip,priority=65500,"
                                f"nw_src=10.0.0.{host_router[0][1]},nw_dst=10.0.0.{host[1]},idle_timeout=0,actions=drop")
                    write_to_terminal(command)
                    execute(command)
                    print(f"i pachetti che vanno da {host_router[0]} a {host} e passano per {host_router[1]} ")

    # Method for deactivating the slice named "file_name" with the aim
    # of deleting the flows added in the method activate_slice
    def deactivate_slice(self, file_name): 
        slice = self.find_slice_by_name(file_name)
        network_topology_hosts = self.get_network_topology_hosts()
        slice_topology = slice.get_slice_topology()
        slice_hosts = self.get_slice_topology_hosts(file_name)
        def find_router_linked_to_the_host(host):
            for host_router in slice.get_host_router_links():
                if host_router[0] == host:
                    return host_router[1]
            return

        slice.deactivate_queue()

        for host_router in slice.get_host_router_links():
            for host in slice_hosts:
                if host != host_router[0]:
                    start_switch = host_router[1]
                    arrival_switch = find_router_linked_to_the_host(host)
                    switch_to_switch_path = self.get_switch_to_switch_path(slice.get_router_router_links(),start_switch,arrival_switch)
                    # switch_to_switch_path = [('s4', 'eth7'), ('s1', 'eth66'), ('s3', 'eth3')]
                    for element in switch_to_switch_path: # ('s4', 'eth7')
                        command = (f"sudo ovs-ofctl del-flows {element[0]} ip," # e.g. s4
                        f"nw_src=10.0.0.{host_router[0][1]},nw_dst=10.0.0.{host[1]}")
                        
                        write_to_terminal(command)
                        execute(command)
            for host in network_topology_hosts:
                if host not in slice_hosts:
                    command = (f"sudo ovs-ofctl del-flows {host_router[1]} ip,"
                                f"nw_src=10.0.0.{host_router[0][1]},nw_dst=10.0.0.{host[1]}")
                    
                    write_to_terminal(command)
                    execute(command)
                    print(f"i pachetti che vanno da {host_router[0]} a {host} e passano per {host_router[1]} ")

        for host_router in slice_topology.get_host_router_links():
            command = (f"sudo ovs-ofctl add-flow {host_router[1]} ip,priority=65500,nw_src=10.0.0.{host_router[0][1]},nw_dst=0.0.0.0/0,idle_timeout=0,actions=drop")
            write_to_terminal(command)
            execute(command)

    # Methods that returns the slice named "file_name"
    def find_slice_by_name(self, file_name):
        for slice in self.slices:
            if slice.slice_name == file_name:
                return slice
        return None  
    
    # Methods for deleting the topology "file_name"
    def delete_topology(self, file_name):
        if file_name != self.network_topology_file_name:
            print("Incorrect network topology file name")
        else:
            self.__init__()

    # Methods for deleting the slice named "file_name"
    def delete_slice(self, file_name):
        slice = self.find_slice_by_name(file_name)
        if slice in self.slices:
            self.slices.remove(slice)
        pass
    
    # Methods for getting the hosts of the network topology
    def get_network_topology_hosts(self):
        return self.network_topology.get_hosts()
    
     # Methods for getting the hosts of the slice topology named "file_name"
    def get_slice_topology_hosts(self, file_name):
        slice = self.find_slice_by_name(file_name)
        return slice.get_hosts()
    
    # This function return a structure like this: [('s4', 'eth7'), ('s1', 'eth66'), ('s3', 'eth3')]
    # If the start_switch is s4 and the arrival_switch is s2, the structure show where the
    # packet should be forwarded: from s4 on port eth7 to reach s1, from s1 on port eth66 to reach s3
    # and finally from s3 on port eth7 to reach s2
    def get_switch_to_switch_path(self, router_router_links, start_switch, arrival_switch): 
        def recursive_search(router_router_links, current_switch, arrival_switch, path=[], visited_links=set()):
            if current_switch == arrival_switch:
                return path

            for link in router_router_links:
                if link[0][0] == current_switch and (link[0][0], link[1][0]) not in visited_links:
                    next_switch = link[1][0]
                    next_eth_port = link[0][1]
                    visited_links.add((link[0][0], link[1][0]))
                    recursive_result = recursive_search(router_router_links, next_switch, arrival_switch, path + [(current_switch,next_eth_port)], visited_links)
                    if recursive_result:
                        return recursive_result

                elif link[1][0] == current_switch and (link[0][0], link[1][0]) not in visited_links:
                    next_switch = link[0][0]
                    next_eth_port = link[1][1]
                    visited_links.add((link[0][0], link[1][0]))
                    recursive_result = recursive_search(router_router_links, next_switch, arrival_switch, path + [(current_switch,next_eth_port)], visited_links)
                    if recursive_result:
                        return recursive_result

            return []

        host_to_host_path = recursive_search(router_router_links, start_switch, arrival_switch)
        return host_to_host_path
        
    def print(self):
        print(f"Network_topology: (file_name)")
        self.network_topology.print()
        print(f"Slices:")
        for slice in self.slices:
            slice.print()
